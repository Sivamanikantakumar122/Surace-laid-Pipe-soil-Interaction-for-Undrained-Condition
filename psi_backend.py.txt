import numpy as np

# --- 1. CORE CALCULATION FUNCTIONS ---

def calculate_effective_weights(Dop, tp, rho_steel=7850, rho_fluid=1000, rho_seawater=1025, g=9.8, klay=2.0):
    """
    Calculates weights and Effective Vertical Force V based on inputs.
    """
    Dip = Dop - 2 * tp
    
    # Weights in kg/m (VBA uses specific constants 7850, 1000, 1025)
    Wp = (np.pi * (Dop**2 - Dip**2) * rho_steel) / 4
    Wcon = (np.pi * (Dip**2) * rho_fluid) / 4
    Wb = (np.pi * (Dop**2) * rho_seawater) / 4
    
    # Flooded weight (kN/m)
    Wpf = ((Wp + Wcon - Wb) * g) / 1000.0
    
    # Installation weight (kg/m)
    Wpins = (np.pi * (Dop**2 - Dip**2) * (rho_steel - rho_seawater)) / 4
    
    # Effective Force V (kN/m)
    V = max((Wpins * klay * g / 1000.0), Wpf)
    
    return V, Wp, Wpf

def calculate_qv_and_abm(Dop, Z, Su, gamma_bulk):
    """
    Calculates Penetration Area (Abm) and Soil Resistance (Qv).
    VBA Reference: '4. Geometric & Penetration Resistance (Qv)'
    """
    Sub_wt = gamma_bulk - 10.05
    
    # Geometric Area (Abm)
    if Z < Dop / 2:
        val = Dop * Z - Z**2
        B = 2 * np.sqrt(val) if val > 0 else 0
        if Dop > 0 and B > 0:
            asin_term = np.arcsin(B / Dop)
            Abm = (asin_term * (Dop**2 / 4)) - (B * (Dop / 4) * np.cos(asin_term))
        else:
            Abm = 0
    else:
        # B = Dop (not used in Abm formula for deep but implied)
        Abm = (np.pi * Dop**2 / 8) + Dop * (Z - Dop / 2)
        
    # Vertical Resistance (Qv)
    if Dop > 0 and Su > 0:
        term1 = 6 * (Z / Dop)**0.25
        term2 = 3.4 * (10 * Z / Dop)**0.5
        min_term = min(term1, term2)
        
        Qv = (min_term + (1.5 * Sub_wt * Abm / (Dop * Su))) * Dop * Su
    else:
        Qv = 0
        
    return Qv, Abm, Sub_wt

def calculate_wedging_and_passive(Dop, Z, Su_passive, Sub_wt, rate):
    """
    Calculates Wedging Factor (zeta) and Lateral Remaining Resistance.
    VBA Reference: '5. Wedging and Passive Resistance'
    """
    # Wedging Factor (zeta)
    cosVal = 1 - Z / (Dop / 2)
    # Clamp value to [-1, 1] for arccos
    cosVal = max(-1.0, min(1.0, cosVal))
    
    beta = np.arccos(cosVal)
    
    denom = beta + np.sin(beta) * np.cos(beta)
    if denom != 0:
        zeta = (2 * np.sin(beta)) / denom
    else:
        zeta = 1.0 # Default fallback
        
    # Lateral Remaining Resistance (Fl_remain)
    Fl_remain = Z * rate * (2 * Su_passive + 0.5 * Sub_wt * Z)
    
    return zeta, Fl_remain

# --- 2. MAIN LOGIC LOOP (REPLACES VBA LOOPS) ---

def run_psi_analysis(inputs):
    """
    Main driver function that mimics the VBA Sub 'PSI_Analysis_UndrainedCase'.
    Takes a dictionary of inputs and returns a list of results for plotting.
    """
    # 1. Unpack Inputs
    Dop = inputs['Dop']
    tp = inputs['tp']
    Z = inputs['Z']
    Su = inputs['Su']
    OCR = inputs['OCR']
    St = inputs['St']
    alpha = inputs['alpha']
    rate = inputs['rate']
    gamma_bulk = inputs['gamma_bulk']
    Su_passive = inputs['Su_passive']
    
    # 2. Base Calculations
    V, Wp, Wpf = calculate_effective_weights(Dop, tp)
    Qv, Abm, Sub_wt = calculate_qv_and_abm(Dop, Z, Su, gamma_bulk)
    zeta, Fl_remain = calculate_wedging_and_passive(Dop, Z, Su_passive, Sub_wt, rate)
    
    results = {
        "metrics": {
            "Wp": Wp, "Wpf": Wpf, "V": V, 
            "Abm": Abm, "Qv": Qv, "zeta": zeta, 
            "Fl_remain": Fl_remain, "Check_V_Qv": (V < Qv)
        },
        "profiles": []
    }
    
    # 3. Loop over Surfaces (Concrete=0, PET=1) just like VBA 'For i = 1 To 2'
    surfaces = ["Concrete", "PET"]
    
    for i, surf_name in enumerate(surfaces):
        # VBA uses index 22-38 to grab these. We pass them in specific keys.
        # Structure: inputs['Concrete_P5_SSR'], etc.
        
        estimates = ["P5", "P50", "P95"]
        
        for est in estimates:
            key_base = f"{surf_name}_{est}" # e.g. "Concrete_P5"
            SSR = inputs[f"{key_base}_SSR"]
            Prem = inputs[f"{key_base}_Prem"]
            
            # --- VBA LOGIC MAPPING ---
            
            # Axial Breakout (Abrk)
            # Abrk = alpha * SSR * OCR ^ Prem * zeta * rate * V
            Abrk = alpha * SSR * (OCR**Prem) * zeta * rate * V
            
            # Axial Residual (Ares)
            Ares = (1.0 / St) * Abrk
            
            # Lateral Breakout (Lbrk)
            # Lbrk = (alpha * SSR * OCR ^ Prem * rate * V) + Fl_remain
            Lbrk = (alpha * SSR * (OCR**Prem) * rate * V) + Fl_remain
            
            # Lateral Residual (Lres)
            # Lres = (0.32 + 0.8 * (Z / Dop) ^ 0.8) * V
            Lres_base = (0.32 + 0.8 * (Z / Dop)**0.8) * V if Dop > 0 else 0
            
            if est == "P5":
                Lres = Lres_base / 1.5
            elif est == "P95":
                Lres = Lres_base * 1.5
            else:
                Lres = Lres_base
                
            # Displacements (using logic from VBA Choose function)
            Dop_mm = Dop * 1000.0
            
            if est == "P5":
                Xb = min(1.25, 0.0025 * Dop_mm)
                Xr = min(7.5, 0.015 * Dop_mm)
                Yb = (0.004 + 0.02 * (Z / Dop)) * Dop_mm
                Yr = 0.6 * Dop_mm
            elif est == "P50":
                Xb = min(5.0, 0.01 * Dop_mm)
                Xr = min(30.0, 0.06 * Dop_mm)
                Yb = (0.02 + 0.25 * (Z / Dop)) * Dop_mm
                Yr = 1.5 * Dop_mm
            else: # P95
                Xb = max(50.0, 0.01 * Dop_mm)
                Xr = max(250.0, 0.5 * Dop_mm)
                Yb = (0.1 + 0.7 * (Z / Dop)) * Dop_mm
                Yr = 2.8 * Dop_mm
                
            # Save data for plotting
            results["profiles"].append({
                "Surface": surf_name,
                "Estimate": est,
                "Axial": {"BreakForce": Abrk, "BreakDisp": Xb, "ResForce": Ares, "ResDisp": Xr},
                "Lateral": {"BreakForce": Lbrk, "BreakDisp": Yb, "ResForce": Lres, "ResDisp": Yr}
            })
            
    return results